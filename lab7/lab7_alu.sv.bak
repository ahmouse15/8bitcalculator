module alu (
	input [7:0] a,
	input [7:0] b,
	input loadA, //Load input register B
	input loadB, //Load input register A
	input out, //Load output register
	
	input clear, //Clear all registers
	input mode, // 0 => addition, 1 => subtraction
	
	output reg [7:0] result,
	output reg [7:0] flags,
	output [0:6] displays [1:0]
);
	//bin_to_seven hex0 (.in(), .out(displays[0]));
	//bin_to_seven hex1 (.in(), .out(displays[0]));
	
	reg [7:0] b_temp;
	
	wire [7:0] a_reg;
	wire [7:0] b_reg;
	wire [7:0] r_reg;
	wire [3:0] cc_reg;
	
	wire [7:0] cout;
	
	register r_a (.in(a), .load(loadA), .clear(clear), .out(a_reg));
	register r_b (.in(b_temp), .load(loadB), .clear(clear), .out(b_reg));
	//register r_r (.in(result), .load(loadB), .clear(clear), .out(b_reg))
	//register r_cc (.in(b_temp), .load(loadB), .clear(clear), .out(b_reg));
	
	
	//8-bit ripple carry adder, from LSB to MSB
	fulladder fa0(.a(a[0]), .b(b[0]), .cin(0), .s(result[0]), .cout(cout[0]));
	fulladder fa1(.a(a[1]), .b(b[1]), .cin(cout[0]), .s(result[1]), .cout(cout[1]));
	fulladder fa2(.a(a[2]), .b(b[2]), .cin(cout[1]), .s(result[2]), .cout(cout[2]));
	fulladder fa3(.a(a[3]), .b(b[3]), .cin(cout[2]), .s(result[3]), .cout(cout[3]));
	fulladder fa4(.a(a[4]), .b(b[4]), .cin(cout[3]), .s(result[4]), .cout(cout[4]));
	fulladder fa5(.a(a[5]), .b(b[5]), .cin(cout[4]), .s(result[5]), .cout(cout[5]));
	fulladder fa6(.a(a[6]), .b(b[6]), .cin(cout[5]), .s(result[6]), .cout(cout[6]));
	fulladder fa7(.a(a[7]), .b(b[7]), .cin(cout[6]), .s(result[7]), .cout(cout[7]));
	
	
	//Negate B if mode is set to subtraction
	always @ (mode, b) begin
		if (mode) begin 
			b_temp = ~b;
			b_temp = b_temp + 1;
		end
		else b_temp = b;
	end
	
	
	
	
endmodule